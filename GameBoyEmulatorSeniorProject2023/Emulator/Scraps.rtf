{\rtf1\ansi\ansicpg1252\cocoartf2707
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red252\green95\blue163;\red31\green31\blue36;\red255\green255\blue255;
\red103\green183\blue164;\red208\green191\blue105;\red103\green183\blue164;\red108\green121\blue134;\red208\green168\blue255;
\red161\green103\blue230;\red65\green161\blue192;\red252\green106\blue93;\red161\green103\blue230;\red158\green241\blue221;
\red84\green130\blue255;\red208\green168\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\csgenericrgb\c98839\c37355\c63833;\csgenericrgb\c12054\c12284\c14131;\csgenericrgb\c100000\c100000\c100000\c85000;
\csgenericrgb\c40538\c71705\c64209;\csgenericrgb\c81498\c74939\c41233;\csgenericrgb\c40392\c71765\c64314;\csgenericrgb\c42394\c47462\c52518;\csgenericrgb\c81681\c65692\c99927;
\csgenericrgb\c63137\c40392\c90196;\csgenericrgb\c25490\c63137\c75294;\csgenericrgb\c98912\c41558\c36568;\csgenericrgb\c63232\c40219\c90115;\csgenericrgb\c62145\c94386\c86819;
\csgenericrgb\c33019\c51127\c99859;\csgenericrgb\c81569\c65882\c100000;\csgray\c0\c0;}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\deftab593
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f0\b\fs24 \cf2 \cb3 if
\f1\b0 \cf4  CPUStateInstance.\cf5 currentOpcode\cf4  == \cf6 0x2A\cf4  \{\
        
\f0\b \cf2 let
\f1\b0 \cf4  value = register + \cf6 1\cf4 ;\
        \cf7 SetHLRegister\cf4 (\cf7 value\cf4 : value);\
    \}\
    
\f0\b \cf2 if
\f1\b0 \cf4  CPUStateInstance.\cf5 currentOpcode\cf4  == \cf6 0x3A\cf4  \{\
        
\f0\b \cf2 let
\f1\b0 \cf4  value = register - \cf6 1\cf4 ;\
        \cf7 SetHLRegister\cf4 (\cf7 value\cf4 : value);\
    \}\

\f0\b \cf2 var
\f1\b0 \cf4  value = \cf7 BusRead\cf4 (\cf7 address\cf4 : \cf7 GetHLRegister\cf4 ()) + \cf6 1\cf4 ;\
    \cf8 //emu cyc\cf4 \
    \cf8 //emu cyc\cf4 \
    \cf7 BusWrite\cf4 (\cf7 address\cf4 : \cf7 GetHLRegister\cf4 (), \cf7 value\cf4 : value);\
\
\
\pard\tx642\pardeftab642\pardirnatural\partightenfactor0

\fs26 \cf4  
\f0\b \cf2 var
\f1\b0 \cf4  fetchedData = \cf9 Int8\cf4 (\cf10 bitPattern\cf4 : \cf7 BusRead\cf4 (\cf7 address\cf4 : \cf5 CPUStateInstance\cf4 .\cf5 registersState\cf4 .\cf5 pc\cf4 ));\
\
\
for debugging\
\cf5 CPUStateInstance\cf4 .\cf5 registersState\cf4 .\cf5 pc\cf4  = \cf9 UInt16\cf4 (\cf9 truncatingIfNeeded\cf4 : \cf9 Int\cf4 (\cf5 CPUStateInstance\cf4 .\cf5 registersState\cf4 .\cf5 pc\cf4 ) + \cf9 Int\cf4 (fetchedData));\

\f0\b \cf2 func
\f1\b0 \cf4  \cf11 CPUStep\cf4 (\cf8 /*CPUStateInstance: CPUState*/\cf4 ) -> \cf9 Bool\cf4 \{\
    
\f0\b \cf2 if
\f1\b0 \cf4  !\cf5 CPUStateInstance\cf4 .halted \{\
        \cf10 print\cf4 (\cf12 "Iteration \cf4 \\(\cf5 i\cf4 )\cf12 \\n"\cf4 )\
\cf5 i\cf4  += \cf6 1\cf4 ;\
            print(\cf5 CPUStateInstance\cf4 .registersState, \cf12 "First print\\n"\cf4 );\
        \cf5 CPUStateInstance\cf4 .currentOpcode = BusRead(address: \cf5 CPUStateInstance\cf4 .registersState.pc);\
        print(\cf12 "executing "\cf4 ,  \cf5 InstructionsTable\cf4 [\cf9 Int\cf4 (\cf5 CPUStateInstance\cf4 .currentOpcode)].\cf13 name\cf4 , \cf9 String\cf4 (\cf9 format\cf4 : \cf12 "0x%X"\cf4 , \cf5 CPUStateInstance\cf4 .currentOpcode));\
        \cf8 //emu cyc\cf4 \
        \cf5 CPUStateInstance\cf4 .registersState.pc+=\cf6 1\cf4 ;\
        \cf10 print\cf4 (BusRead(address: \cf5 CPUStateInstance\cf4 .registersState.pc));\
        \cf5 InstructionsTable\cf4 [\cf9 Int\cf4 (\cf5 CPUStateInstance\cf4 .currentOpcode)].instructionFunction();\
            print(\cf5 CPUStateInstance\cf4 .registersState, \cf12 "second print\\n"\cf4 );\
    \}\
    
\f0\b \cf2 return
\f1\b0 \cf4  
\f0\b \cf2 false
\f1\b0 \cf4 ;\
\}\
\
\cf8 //print(UInt16(truncatingIfNeeded: UInt16(Int(537) + Int(Int8(bitPattern: BusRead(address: 537))))))\cf4 \
\cf10 print\cf4 (\cf9 Int8\cf4 (\cf10 bitPattern\cf4 : BusRead(address: \cf6 518\cf4 )))\
\cf9 UInt16\cf4 (\cf9 truncatingIfNeeded\cf4 : \cf9 Int\cf4 (\cf6 519\cf4 ) + \cf9 Int\cf4 ( \cf9 Int8\cf4 (\cf10 bitPattern\cf4 : BusRead(address: \cf6 518\cf4 )) ) )\

\f0\b \cf2 while
\f1\b0 \cf4  !\cf5 CPUStateInstance\cf4 .halted \{\
    \cf8 // Code to be executed in each iteration\cf4 \
    \
    CPUStep();\
\}\
\
\
\cf8 //InstructionsTable[Int(CPUStateInstance.currentOpcode)].instructionFunction();\cf4 \
\

\f0\b \cf2 for
\f1\b0 \cf4  i 
\f0\b \cf2 in
\f1\b0 \cf4  \cf6 0x11\cf4 ...\cf6 0xFF\cf4  \{\
    \cf10 print\cf4 (\cf12 "Iteration \cf4 \\(\cf5 i\cf4 )\cf12 \\n"\cf4 )\
    print(\cf5 CPUStateInstance\cf4 .registersState, \cf12 "First print\\n"\cf4 , \cf12 "HL: "\cf4 , \cf9 String\cf4 (\cf9 format\cf4 : \cf12 "0x%X"\cf4 , GetHLRegister()));\
    \cf8 // Code to be executed in each iteration\cf4 \
    print(\cf12 "executing "\cf4 ,  \cf5 InstructionsTable\cf4 [\cf5 i\cf4 ].\cf13 name\cf4 , \cf9 String\cf4 (\cf9 format\cf4 : \cf12 "0x%X"\cf4 , \cf5 i\cf4 ));\
    \cf5 InstructionsTable\cf4 [\cf5 i\cf4 ].instructionFunction();\
    \
    print(\cf5 CPUStateInstance\cf4 .registersState, \cf12 "second print\\n"\cf4 , \cf12 "HL: "\cf4 , \cf9 String\cf4 (\cf9 format\cf4 : \cf12 "0x%X"\cf4 , GetHLRegister()));\
\}\
\
\cf8 /*\cf4 \
\cf8 SetHLRegister(value: 0x9F0F)\cf4 \
\cf8 print(CPUStateInstance.registersState, "First print\\n", "HL: ", String(format: "0x%X", GetHLRegister()));\cf4 \
\cf8 print("executing ",  InstructionsTable[0x29].name);\cf4 \
\cf8 InstructionsTable[0x29].instructionFunction();\cf4 \
\cf8 print(CPUStateInstance.registersState, "second print\\n", "HL: ", String(format: "0x%X", GetHLRegister()));\cf4 \
\cf8 */\
\
\
\
emulator starts with\
getcartridgestate\
then generate instruction table\
start emulator\
cpu step\

\f0\b \cf2 var
\f1\b0 \cf4  \cf11 fileURL\cf4 : \cf9 URL\cf4  = \cf9 URL\cf4 (\cf10 string\cf4 : \cf12 "file:///Users/franksalgado/Documents/roms/01-special.gb"\cf4 )!;\
\
\
\
\
\pard\tx642\pardeftab642\pardirnatural\partightenfactor0

\f0\b \cf4 \cb1 \CocoaLigature0 Registers(a: 0, f: 0, b: 1, c: 16, d: 192, e: 0, h: 116, l: 86, sp: 65534, pc: 518) second print\
\
CPURegisters(a: 0, f: 0, b: 1, c: 16, d: 192, e: 0, h: 116, l: 86, sp: 65534, pc: 518) First print\
\
executing  LDAAddressHLInc 0x2A\
18\
CPURegisters(a: 0, f: 0, b: 1, c: 16, d: 192, e: 0, h: 116, l: 87, sp: 65534, pc: 521) second print\
\
CPURegisters(a: 0, f: 0, b: 1, c: 16, d: 192, e: 0, h: 116, l: 87, sp: 65534, pc: 521) First print\
\
executing  JRNZr8 0x20\
251\
CPURegisters(a: 0, f: 0, b: 1, c: 16, d: 192, e: 0, h: 116, l: 87, sp: 65534, pc: 518) second print\
\
CPURegisters(a: 0, f: 0, b: 1, c: 16, d: 192, e: 0, h: 116, l: 87, sp: 65534, pc: 518) First print\
\
executing  LDAAddressHLInc 0x2A\
18\
CPURegisters(a: 0, f: 0, b: 1, c: 16, d: 192, e: 0, h: 116, l: 88, sp: 65534, pc: 521) second print\
\
CPURegisters(a: 0, f: 0, b: 1, c: 16, d: 192, e: 0, h: 116, l: 88, sp: 65534, pc: 521) First print\
\
executing  JRNZr8 0x20\
251\
CPURegisters(a: 0, f: 0, b: 1, c: 16, d: 192, e: 0, h: 116, l: 88, sp: 65534, pc: 518) second print\
\pard\tx642\pardeftab642\pardirnatural\partightenfactor0

\f1\b0 \cf4 \cb3 \CocoaLigature1 \
\
\

\f0\b \cf2 var
\f1\b0 \cf4  \cf11 i\cf4  = \cf6 0\cf4 ;\

\f0\b \cf2 func
\f1\b0 \cf4  \cf11 CPUStep\cf4 () -> \cf9 Bool\cf4 \{\
print(\cf12 "Interation: "\cf4 , \cf5 i\cf4 , \cf12 "\\n"\cf4 );\
    \cf5 i\cf4  += \cf6 1\cf4 ;\
    
\f0\b \cf2 if
\f1\b0 \cf4  !\cf5 CPUStateInstance\cf4 .halted \{\
        print(\cf5 CPUStateInstance\cf4 .registersState, \cf12 "First print\\n"\cf4 , \cf12 "\\nHL: "\cf4 , \cf9 String\cf4 (\cf9 format\cf4 : \cf12 "0x%X"\cf4 , GetHLRegister()), \cf12 "\\n"\cf4 );\
        \
        \
        \cf5 CPUStateInstance\cf4 .currentOpcode = BusRead(address: \cf5 CPUStateInstance\cf4 .registersState.pc);\
        \
        \
        print(\cf12 "executing "\cf4 ,  \cf5 InstructionsTable\cf4 [\cf9 Int\cf4 (\cf5 CPUStateInstance\cf4 .currentOpcode)].\cf13 name\cf4 , \cf9 String\cf4 (\cf9 format\cf4 : \cf12 "0x%X"\cf4 , \cf5 CPUStateInstance\cf4 .currentOpcode));\
        \
        \
        EmulatorCycles(CPUCycles: \cf6 1\cf4 );\
        \cf5 CPUStateInstance\cf4 .registersState.pc+=\cf6 1\cf4 ;\
        \
        \
        print(\cf12 "Next opcode: "\cf4 , BusRead(address: \cf5 CPUStateInstance\cf4 .registersState.pc));\
        \cf8 //TestRomWrite();\cf4 \
        \cf8 //TestRomRead();\cf4 \
        \
        \
        \cf5 InstructionsTable\cf4 [\cf9 Int\cf4 (\cf5 CPUStateInstance\cf4 .currentOpcode)].instructionFunction();\
        \
        \
        print(\cf5 CPUStateInstance\cf4 .registersState, \cf12 "second print\\n"\cf4 , \cf12 "\\nHL: "\cf4 , \cf9 String\cf4 (\cf9 format\cf4 : \cf12 "0x%X"\cf4 , GetHLRegister()), \cf12 "\\n"\cf4 );\
\pard\tx692\pardeftab692\pardirnatural\partightenfactor0

\fs28 \cf4   
\f0\b \cf2 let
\f1\b0 \cf4  messageString = \cf9 String\cf4 (\cf5 TestRomMessage\cf4 .\cf10 map\cf4  \{ \cf9 Character\cf4 (\cf9 UnicodeScalar\cf4 ($0)) \})\
        
\f0\b \cf2 if
\f1\b0 \cf4  messageString.\cf10 contains\cf4 (\cf12 "Passed"\cf4 ) \{\
            \cf10 print\cf4 (messageString)\
        \}\
\
\
\
\
\
ppu scraps\

\f0\b \cf2 var
\f1\b0 \cf4  \cf11 num1\cf4 : \cf9 UInt8\cf4  = \cf6 0b11111111\cf4 \

\f0\b \cf2 var
\f1\b0 \cf4  \cf11 num2\cf4 : \cf9 UInt8\cf4  = \cf6 0b00000000\cf4 \
\

\f0\b \cf2 var
\f1\b0 \cf4  \cf11 columnIndex\cf4  = \cf6 0\cf4 \

\f0\b \cf2 var
\f1\b0 \cf4  \cf11 rowIndex\cf4  = \cf6 0\cf4 \

\f0\b \cf2 var
\f1\b0 \cf4  \cf11 arrayInd\cf4  = \cf6 0\cf4 \

\f0\b \cf2 var
\f1\b0 \cf4  \cf11 line\cf4 : \cf9 UInt16\cf4  = \cf6 0\cf4 \

\f0\b \cf2 while
\f1\b0 \cf4  \cf5 arrayInd\cf4  < \cf6 64\cf4  \{\
    
\f0\b \cf2 var
\f1\b0 \cf4  byteVal1 = \cf6 0\cf4 \
    
\f0\b \cf2 var
\f1\b0 \cf4  byteVal2 = \cf6 0\cf4 \
    
\f0\b \cf2 if
\f1\b0 \cf4  \cf5 num1\cf4  & (\cf6 1\cf4  << \cf5 columnIndex\cf4 ) == (\cf6 1\cf4  << \cf5 columnIndex\cf4 ) \{\
        byteVal1 = \cf6 1\cf4 \
    \}\
    
\f0\b \cf2 if
\f1\b0 \cf4  \cf5 num2\cf4  & (\cf6 1\cf4  << \cf5 columnIndex\cf4 ) == (\cf6 1\cf4  << \cf5 columnIndex\cf4 ) \{\
        byteVal1 = \cf6 1\cf4 \
    \}\
    \cf5 line\cf4  |= (byteVal1 << (\cf6 2\cf4  * \cf5 columnIndex\cf4 ) )\
    \
    \cf5 line\cf4  |= (byteVal2 << (\cf6 2\cf4  * (\cf5 columnIndex\cf4  - \cf6 1\cf4 ) )\
    \cf5 columnIndex\cf4  -= \cf6 1\cf4 \
    
\f0\b \cf2 if
\f1\b0 \cf4  \cf5 rowIndex\cf4  == \cf6 0\cf4  \{\
        \cf5 rowIndex\cf4  = \cf6 7\cf4 \
        \cf5 rowIndex\cf4  += \cf6 1\cf4 \
    \}\
    \cf5 arrayInd\cf4  += \cf6 1\cf4 ;\
\}\
\
\
\
\
\
\pard\tx791\pardeftab791\pardirnatural\partightenfactor0

\f0\b\fs32 \cf2 func
\f1\b0 \cf4  \cf11 InitializeCartridgeState\cf4 () -> \cf14 CartridgeState\cf4  \{\
    \cf8 /*\cf4 \
\cf8     let fileManager = FileManager.default\cf4 \
\cf8     if fileManager.fileExists(atPath: "\cf15 file:///Users/franksalgado/Documents/roms/tetris.gb\cf8 " ) \{\cf4 \
\cf8         print("File Exists")\cf4 \
\cf8     \} else \{\cf4 \
\cf8         print(" not File Exists")\cf4 \
\cf8     \}\cf4 \
\
\cf8     */\cf4 \
    \cf8 //Get the data from the rom file\cf4 \
    
\f0\b \cf2 var
\f1\b0 \cf4  fileURL: \cf9 URL\cf4  = \cf9 URL\cf4 (\cf10 string\cf4 : \cf12 "file:///Users/franksalgado/Documents/roms/1.gb"\cf4 )!;\
    
\f0\b \cf2 let
\f1\b0 \cf4  data = 
\f0\b \cf2 try
\f1\b0 \cf4 ! \cf9 Data\cf4 (\cf10 contentsOf\cf4 : fileURL)\
\
    \cf8 //Store data in 8 bit array form\cf4 \
    
\f0\b \cf2 let
\f1\b0 \cf4  romDataInArray = [\cf9 UInt8\cf4 ](data);\
    
\f0\b \cf2 var
\f1\b0 \cf4  sizeInBytes: \cf9 UInt32\cf4  = \cf6 0\cf4 ;\
    
\f0\b \cf2 for
\f1\b0 \cf4  _ 
\f0\b \cf2 in
\f1\b0 \cf4  romDataInArray \{\
        sizeInBytes += \cf6 1\cf4 ;\
    \}\
    \
    
\f0\b \cf2 let
\f1\b0 \cf4  romDataInMemory = \cf9 UnsafeMutablePointer\cf4 <\cf9 UInt8\cf4 >.\cf10 allocate\cf4 (\cf10 capacity\cf4 : \cf9 Int\cf4 (sizeInBytes));\
    romDataInMemory.\cf10 initialize\cf4 (\cf10 from\cf4 : romDataInArray, \cf10 count\cf4 : \cf9 Int\cf4 (sizeInBytes));\
    \cf8 //memcpy(romDataInMemory, romDataInArray, Int(sizeInBytes));\cf4 \
    
\f0\b \cf2 let
\f1\b0 \cf4  CartridgeState = \cf14 CartridgeState\cf4 (\cf7 romSize\cf4 : sizeInBytes, \cf7 romDataInArray\cf4 : romDataInArray, \cf7 romDataInMemory\cf4 : romDataInMemory);\
    print(\cf12 "Hi"\cf4 , \cf5 CartridgeStateInstance\cf4 .\cf5 romSize\cf4 );\
    
\f0\b \cf2 return
\f1\b0 \cf4  CartridgeState;\
\}\
\
 
\f0\b \cf2 override
\f1\b0 \cf4  
\f0\b \cf2 func
\f1\b0 \cf4  \cf11 sceneDidLoad\cf4 () \{\
        \
        
\f0\b \cf2 self
\f1\b0 \cf4 .\cf5 lastUpdateTime\cf4  = \cf6 0\cf4 \
        \cf7 renderTilemap\cf4 ();\
        \cf8 /*\cf4 \
\cf8         let pixelNode = SKSpriteNode(color: .red, size: CGSize(width: 1, height: 1));\cf4 \
\cf8         pixelNode.position = CGPoint(x: 0, y: 0);\cf4 \
\cf8         pixelNode.zPosition = 1;\cf4 \
\cf8         self.addChild(pixelNode);\cf4 \
\cf8          \cf4 \
\cf8         let pixelNode = SKSpriteNode(color: .red, size: CGSize(width: 1, height: 1));\cf4 \
\cf8         pixelNode.position = CGPoint(x: -80, y: 72);\cf4 \
\cf8         pixelNode.zPosition = 5;\cf4 \
\cf8         self.addChild(pixelNode);\cf4 \
\cf8         let pixelNodea = SKSpriteNode(color: .red, size: CGSize(width: 1, height: 1));\cf4 \
\cf8         pixelNodea.position = CGPoint(x: 48, y: -120);\cf4 \
\cf8         pixelNodea.zPosition = 5;\cf4 \
\cf8         self.addChild(pixelNodea);\cf4 \
\cf8          */\cf4 \
    \}\
\

\f0\b \cf2 func
\f1\b0 \cf4  \cf11 InitializeCartridgeState\cf4 () -> \cf14 CartridgeState\cf4  \{\
    
\f0\b \cf2 let
\f1\b0 \cf4  fileManager = \cf16 FileManager\cf4 ()\
    
\f0\b \cf2 let
\f1\b0 \cf4  openPanel = \cf16 NSOpenPanel\cf4 ()\
    openPanel.\cf13 allowedFileTypes\cf4  = [\cf12 "gb"\cf4 ]\
    openPanel.\cf13 canChooseFiles\cf4  = 
\f0\b \cf2 true
\f1\b0 \cf4 \
    openPanel.\cf13 canChooseDirectories\cf4  = 
\f0\b \cf2 false
\f1\b0 \cf4 \
    \
    
\f0\b \cf2 guard
\f1\b0 \cf4  openPanel.\cf10 runModal\cf4 () == .\cf13 OK\cf4  
\f0\b \cf2 else
\f1\b0 \cf4  \{\
        \cf10 exit\cf4 (-\cf6 5\cf4 )\
    \}\
    \
    
\f0\b \cf2 guard
\f1\b0 \cf4  
\f0\b \cf2 let
\f1\b0 \cf4  url = openPanel.\cf13 urls\cf4 .\cf10 first\cf4  
\f0\b \cf2 else
\f1\b0 \cf4  \{\
        \cf10 exit\cf4 (-\cf6 5\cf4 )\
    \}\
    \
    
\f0\b \cf2 do
\f1\b0 \cf4  \{\
        \cf10 print\cf4 (\cf12 "Initcartexecuted"\cf4 )\
        
\f0\b \cf2 let
\f1\b0 \cf4  data = 
\f0\b \cf2 try
\f1\b0 \cf4  \cf9 Data\cf4 (\cf10 contentsOf\cf4 : url);\
        
\f0\b \cf2 let
\f1\b0 \cf4  romDataInArray = [\cf9 UInt8\cf4 ](data);\
        
\f0\b \cf2 let
\f1\b0 \cf4  sizeInBytes = \cf9 UInt32\cf4 (romDataInArray.\cf13 count\cf4 );\
        
\f0\b \cf2 let
\f1\b0 \cf4  romDataInMemory = \cf9 UnsafeMutablePointer\cf4 <\cf9 UInt8\cf4 >.\cf10 allocate\cf4 (\cf10 capacity\cf4 : \cf9 Int\cf4 (sizeInBytes))\
        romDataInMemory.\cf10 initialize\cf4 (\cf10 from\cf4 : romDataInArray, \cf10 count\cf4 : \cf9 Int\cf4 (sizeInBytes))\
        
\f0\b \cf2 let
\f1\b0 \cf4  cartridgeState = \cf14 CartridgeState\cf4 (\cf7 romSize\cf4 : sizeInBytes, \cf7 romDataInArray\cf4 : romDataInArray, \cf7 romDataInMemory\cf4 : romDataInMemory)\
        \cf10 print\cf4 (cartridgeState.\cf5 romSize\cf4 )\
        
\f0\b \cf2 return
\f1\b0 \cf4  cartridgeState\
    \} 
\f0\b \cf2 catch
\f1\b0 \cf4  \{\
        \cf10 print\cf4 (\cf12 "Error reading file: \cf4 \\(error.\cf13 localizedDescription\cf4 )\cf12 "\cf4 )\
        \cf10 exit\cf4 (-\cf6 5\cf4 )\
    \}\
\}\
\
class GameScene: SKScene \{\
    \
    var entities = [GKEntity]()\
    var graphs = [String : GKGraph]()\
    \
    private var lastUpdateTime : TimeInterval = 0\
    private var label : SKLabelNode?\
    private var spinnyNode : SKShapeNode?\
    private var pixelNodes = [SKSpriteNode]()\
    \
    override func sceneDidLoad() \{\
        self.lastUpdateTime = 0\
        createPixelNodes()\
        renderTilemap()\
    \}\
    \
    func createPixelNodes() \{\
        // Create 64x64 pixel nodes and add them as children of the scene\
        for y in 0..<64 \{\
            for x in 0..<64 \{\
                let pixelNode = SKSpriteNode(color: SKColor.white, size: CGSize(width: 1, height: 1))\
                pixelNode.position = CGPoint(x: x - 32, y: -y + 32)\
                pixelNode.zPosition = -1\
                self.addChild(pixelNode)\
                pixelNodes.append(pixelNode)\
            \}\
        \}\
    \}\
    \
    func getPixelIndex(x: Int, y: Int) -> Int \{\
        // Convert x, y coordinates to pixel index\
        return (y * 64) + x\
    \}\
    \
    func setPixelColor(x: Int, y: Int, color: SKColor) \{\
        // Set the color of the pixel at the given x, y coordinates\
        let index = getPixelIndex(x: x, y: y)\
        pixelNodes[index].color = color\
    \}\
    \
    func getPixelColor(value: UInt8) -> SKColor \{\
        // Return the color for the given value\
        switch value \{\
        case 0:\
            return SKColor.white\
        case 1:\
            return SKColor(red: 0.0, green: 0.4, blue: 0.8, alpha: 1.0)\
        case 2:\
            return SKColor(red: 0.0, green: 0.4, blue: 0.8, alpha: 1.0)\
        case 3:\
            return SKColor(red: 0.0, green: 0.1, blue: 0.3, alpha: 1.0)\
        default:\
            return SKColor.clear\
        \}\
    \}\
    \
    func tileByteCalculaion(tileIndex: UInt16, y: Int) -> UInt8 \{\
        let tileOffset:UInt16 = tileIndex * 16;\
        let rowOffset:UInt16  = UInt16(y * 2);\
        let address:UInt16 = 0x8000 + tileOffset + rowOffset;\
        return BusRead(address: address);\
    \}\
    \
    func renderTile(atPoint pos : CGPoint, tileIndex: UInt16) \{\
        // Loop through each pixel in the tile and set its color based on the UInt8 value\
        for y in (0..<8) \{\
            let firstByte: UInt8 = tileByteCalculaion(tileIndex: tileIndex, y: y);\
            let secondByte: UInt8 = tileByteCalculaion(tileIndex: tileIndex, y: y + 1);\
            let colorValue: [UInt8] = GetTileLineBytes(first\
\
\
\
\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\fs24 \cf4  
\f0\b \cf2 func
\f1\b0 \cf4  \cf11 getPixelColor\cf4 (\cf11 value\cf4 : \cf9 UInt8\cf4 ) -> \cf9 SKColor\cf4  \{\
        
\f0\b \cf2 switch
\f1\b0 \cf4  value \{\
        
\f0\b \cf2 case
\f1\b0 \cf4  \cf6 0\cf4 :\
            
\f0\b \cf2 return
\f1\b0 \cf4  \cf9 SKColor\cf4 (\cf9 red\cf4 : \cf6 1.0\cf4 , \cf9 green\cf4 : \cf6 1.0\cf4 , \cf9 blue\cf4 : \cf6 1.0\cf4 , \cf9 alpha\cf4 : \cf6 1.0\cf4 );  \cf8 // White\cf4 \
            
\f0\b \cf2 case
\f1\b0 \cf4  \cf6 1\cf4 :\
            
\f0\b \cf2 return
\f1\b0 \cf4  \cf9 SKColor\cf4 (\cf9 red\cf4 : \cf6 0.0\cf4 , \cf9 green\cf4 : \cf6 0.4\cf4 , \cf9 blue\cf4 : \cf6 0.8\cf4 , \cf9 alpha\cf4 : \cf6 1.0\cf4 );  \cf8 // Light blue\cf4 \
            
\f0\b \cf2 case
\f1\b0 \cf4  \cf6 2\cf4 :\
            
\f0\b \cf2 return
\f1\b0 \cf4  \cf9 SKColor\cf4 (\cf9 red\cf4 : \cf6 0.0\cf4 , \cf9 green\cf4 : \cf6 0.4\cf4 , \cf9 blue\cf4 : \cf6 0.8\cf4 , \cf9 alpha\cf4 : \cf6 1.0\cf4 );   \cf8 // Dark blue\cf4 \
            
\f0\b \cf2 case
\f1\b0 \cf4  \cf6 3\cf4 :\
            
\f0\b \cf2 return
\f1\b0 \cf4  \cf9 SKColor\cf4 (\cf9 red\cf4 : \cf6 0.0\cf4 , \cf9 green\cf4 : \cf6 0.1\cf4 , \cf9 blue\cf4 : \cf6 0.3\cf4 , \cf9 alpha\cf4 : \cf6 1.0\cf4 );    \cf8 // Navy blue\cf4 \
        
\f0\b \cf2 default
\f1\b0 \cf4 :\
            \cf10 print\cf4 (\cf12 "Invalid color index"\cf4 );\
            \cf10 exit\cf4 (-\cf6 5\cf4 );\
            \}\
        \}\
\
\
\
\

\f0\b \cf2 func
\f1\b0 \cf4  \cf11 BusRead\cf4 (\cf11 address\cf4 : \cf9 UInt16\cf4 ) -> \cf9 UInt8\cf4  \{\
    
\f0\b \cf2 switch
\f1\b0 \cf4  address\{\
        
\f0\b \cf2 if
\f1\b0 \cf4  address < \cf6 0x8000\cf4  \{\
            
\f0\b \cf2 return
\f1\b0 \cf4  \cf7 CartridgeRead\cf4 (\cf7 address\cf4 : address);\
        \}\
        
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address < \cf6 0xA000\cf4  \{\
            
\f0\b \cf2 return
\f1\b0 \cf4  \cf5 PPUStateInstance\cf4 .\cf5 vram\cf4 [\cf9 Int\cf4 (address) - \cf6 0x8000\cf4 ];\
        \}\
        
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address < \cf6 0xC000\cf4  \{\
            
\f0\b \cf2 return
\f1\b0 \cf4  \cf7 CartridgeRead\cf4 (\cf7 address\cf4 : address);\
        \}\
        
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address < \cf6 0xE000\cf4  \{\
            
\f0\b \cf2 let
\f1\b0 \cf4  workingRAMAddress = address &- \cf6 0xC000\cf4 ;\
            
\f0\b \cf2 if
\f1\b0 \cf4  workingRAMAddress >= \cf6 0x2000\cf4  \{\
                \cf10 print\cf4 (\cf12 "invalid wram read"\cf4 );\
                \cf10 exit\cf4 (-\cf6 5\cf4 )\
            \}\
            
\f0\b \cf2 return
\f1\b0 \cf4  \cf5 RAMStateInstance\cf4 .\cf5 workingRAM\cf4 [\cf9 Int\cf4 (workingRAMAddress)];\
        \}\
        
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address < \cf6 0xFE00\cf4  \{\
            \cf8 //implement\cf4 \
        \}\
        
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address < \cf6 0xFEA0\cf4  \{\
            \cf8 // ppu\cf4 \
            
\f0\b \cf2 if
\f1\b0 \cf4  \cf7 DMATransferring\cf4 () \{\
                
\f0\b \cf2 return
\f1\b0 \cf4  \cf6 0xFF\cf4 ;\
            \}\
            
\f0\b \cf2 return
\f1\b0 \cf4  \cf7 PPUOAMread\cf4 (\cf7 address\cf4 : address);\
        \}\
        
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address < \cf6 0xFF00\cf4  \{\
            \cf8 //unusable\cf4 \
        \}\
        
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address < \cf6 0xFF80\cf4  \{\
            
\f0\b \cf2 return
\f1\b0 \cf4  \cf7 IORead\cf4 (\cf7 address\cf4 : address);\
        \}\
        
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address == \cf6 0xFFFF\cf4  \{\
            
\f0\b \cf2 return
\f1\b0 \cf4  \cf7 GetInterruptEnableRegister\cf4 ();\
        \}\
        
\f0\b \cf2 return
\f1\b0 \cf4  \cf5 RAMStateInstance\cf4 .\cf5 highRAM\cf4 [\cf9 Int\cf4 (address &- \cf6 0xFF80\cf4 )];\
    \}\
\}\
\
\

\f0\b \cf2 func
\f1\b0 \cf4  \cf11 BusWrite\cf4 (\cf11 address\cf4 : \cf9 UInt16\cf4 , \cf11 value\cf4 : \cf9 UInt8\cf4 ) \{\
    
\f0\b \cf2 if
\f1\b0 \cf4  (address < \cf6 0x8000\cf4 ) \{\
        \cf7 CartridgeWrite\cf4 (\cf7 address\cf4 : address, \cf7 value\cf4 : value);\
    \}\
    
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address < \cf6 0xA000\cf4  \{\
        \cf5 PPUStateInstance\cf4 .\cf5 vram\cf4 [\cf9 Int\cf4 (address) - \cf6 0x8000\cf4 ] = value;\
    \}\
    
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address < \cf6 0xC000\cf4  \{\
        \cf7 CartridgeWrite\cf4 (\cf7 address\cf4 : address, \cf7 value\cf4 : value);\
    \}\
    
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address < \cf6 0xE000\cf4  \{\
        \cf5 RAMStateInstance\cf4 .\cf5 workingRAM\cf4 [\cf9 Int\cf4 (address &- \cf6 0xC000\cf4 )] = value;\
    \}\
    
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address < \cf6 0xFE00\cf4  \{\
        \cf8 //implement\cf4 \
    \}\
    
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address < \cf6 0xFEA0\cf4  \{\
        \cf8 //ppu\cf4 \
        
\f0\b \cf2 if
\f1\b0 \cf4  \cf7 DMATransferring\cf4 () \{\
            
\f0\b \cf2 return
\f1\b0 \cf4 ;\
        \}\
        \cf7 PPUOAMWrite\cf4 (\cf7 address\cf4 : address, \cf7 value\cf4 : value);\
    \}\
    
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address < \cf6 0xFF00\cf4  \{\
        \cf8 //unusable\cf4 \
    \}\
    
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address < \cf6 0xFF80\cf4  \{\
        \cf7 IOWrite\cf4 (\cf7 address\cf4 : address, \cf7 value\cf4 : value);\
    \}\
    
\f0\b \cf2 else
\f1\b0 \cf4  
\f0\b \cf2 if
\f1\b0 \cf4  address == \cf6 0xFFFF\cf4  \{\
        \cf7 SetInterruptEnableRegister\cf4 (\cf7 value\cf4 : value);\
    \}\
    
\f0\b \cf2 else
\f1\b0 \cf4 \{\
        \cf5 RAMStateInstance\cf4 .\cf5 highRAM\cf4 [\cf9 Int\cf4 (address &- \cf6 0xFF80\cf4 )] = value;\
    \}\
\}
\fs32 \
\pard\tx791\pardeftab791\pardirnatural\partightenfactor0
\cf4 \
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\fs24 \cf4  
\f0\b \cf2 func
\f1\b0 \cf4  \cf11 getPixelColor\cf4 (\cf11 value\cf4 : \cf9 UInt8\cf4 ) -> \cf9 SKColor\cf4  \{\
        
\f0\b \cf2 switch
\f1\b0 \cf4  value \{\
        
\f0\b \cf2 case
\f1\b0 \cf4  \cf6 0\cf4 :\
            
\f0\b \cf2 return
\f1\b0 \cf4  \cf5 LCDStateInstance\cf4 .\cf5 backGroundColors\cf4 [\cf6 0\cf4 ];  \cf8 // Lightest Green\cf4 \
        
\f0\b \cf2 case
\f1\b0 \cf4  \cf6 1\cf4 :\
            
\f0\b \cf2 return
\f1\b0 \cf4   \cf5 LCDStateInstance\cf4 .\cf5 backGroundColors\cf4 [\cf6 1\cf4 ];  \cf8 // Light Green\cf4 \
        
\f0\b \cf2 case
\f1\b0 \cf4  \cf6 2\cf4 :\
            
\f0\b \cf2 return
\f1\b0 \cf4   \cf5 LCDStateInstance\cf4 .\cf5 backGroundColors\cf4 [\cf6 2\cf4 ];  \cf8 // Dark Green\cf4 \
        
\f0\b \cf2 case
\f1\b0 \cf4  \cf6 3\cf4 :\
            
\f0\b \cf2 return
\f1\b0 \cf4   \cf5 LCDStateInstance\cf4 .\cf5 backGroundColors\cf4 [\cf6 3\cf4 ];  \cf8 // Darkest Green\cf4 \
        
\f0\b \cf2 default
\f1\b0 \cf4 :\
            \cf10 print\cf4 (\cf12 "Invalid color index"\cf4 );\
            \cf10 exit\cf4 (-\cf6 5\cf4 );\
        \}\
    \}\
\
    \cf8 //Used in GameScene class to get the bytes to render all 8 pixels for a tile.\cf4 \
    
\f0\b \cf2 let
\f1\b0 \cf4  \cf11 binaryNumbers\cf4 : [\cf9 UInt8\cf4 ] = [\cf6 0b10000000\cf4 , \cf6 0b01000000\cf4 , \cf6 0b00100000\cf4 , \cf6 0b00010000\cf4 , \cf6 0b00001000\cf4 , \cf6 0b00000100\cf4 , \cf6 0b00000010\cf4 , \cf6 0b00000001\cf4 ];\
    
\f0\b \cf2 func
\f1\b0 \cf4  \cf11 GetTileLineBytes\cf4 (\cf11 firstByte\cf4 : \cf9 UInt8\cf4 , \cf11 secondByte\cf4 : \cf9 UInt8\cf4 ) -> [\cf9 UInt8\cf4 ] \{\
        
\f0\b \cf2 var
\f1\b0 \cf4  i = \cf6 0\cf4 ;\
        
\f0\b \cf2 var
\f1\b0 \cf4  number: \cf9 UInt8\cf4  = \cf6 0\cf4 ;\
        
\f0\b \cf2 var
\f1\b0 \cf4  array: [\cf9 UInt8\cf4 ] = \cf9 Array\cf4 <\cf9 UInt8\cf4 >(repeating: \cf6 0\cf4  , count: \cf6 8\cf4 );\
        
\f0\b \cf2 while
\f1\b0 \cf4  i < \cf6 8\cf4  \{\
            number = \cf6 0\cf4 ;\
            
\f0\b \cf2 if
\f1\b0 \cf4  firstByte & \cf5 binaryNumbers\cf4 [i] != \cf6 0\cf4  \{\
                number |= (\cf6 1\cf4  <<  \cf6 1\cf4 );\
            \}\
            
\f0\b \cf2 if
\f1\b0 \cf4  secondByte & \cf5 binaryNumbers\cf4 [i] != \cf6 0\cf4  \{\
                number |= \cf6 1\cf4 ;\
            \}\
            array[i] = number\
            i += \cf6 1\cf4 ;\
        \}\
        
\f0\b \cf2 return
\f1\b0 \cf4  array;\
    \}\
    \
    \cf8 //Each tile is composed of 16 bytes. Each line is 2 bytes vram starts at address 0x8000\cf4 \
    
\f0\b \cf2 func
\f1\b0 \cf4  \cf11 tileByteCalculaion\cf4 (\cf11 tileIndex\cf4 : \cf9 UInt16\cf4 , \cf11 y\cf4 : \cf9 Int\cf4 ) -> \cf9 UInt8\cf4  \{\
        
\f0\b \cf2 let
\f1\b0 \cf4  tileOffset:\cf9 UInt16\cf4  = tileIndex * \cf6 16\cf4 ;\
        
\f0\b \cf2 let
\f1\b0 \cf4  rowOffset:\cf9 UInt16\cf4   = \cf9 UInt16\cf4 (y * \cf6 2\cf4 );\
        
\f0\b \cf2 let
\f1\b0 \cf4  address:\cf9 UInt16\cf4  = \cf6 0x8000\cf4  + tileOffset + rowOffset;\
        
\f0\b \cf2 return
\f1\b0 \cf4  \cf7 BusRead\cf4 (\cf7 address\cf4 : address);\
    \}\
    \
    
\f0\b \cf2 func
\f1\b0 \cf4  \cf11 renderTile\cf4 ( \cf11 tileIndex\cf4 : \cf9 UInt16\cf4 ) \{\
       \cf8 // let tileSize = CGSize(width: 8, height: 8);\cf4 \
        \cf8 // Loop through each pixel in the tile and set its color based on the UInt8 value\cf4 \
        
\f0\b \cf2 for
\f1\b0 \cf4  y 
\f0\b \cf2 in
\f1\b0 \cf4  \cf6 0\cf4 ..<\cf6 8\cf4  \{\
            
\f0\b \cf2 let
\f1\b0 \cf4  firstByte: \cf9 UInt8\cf4  = \cf7 tileByteCalculaion\cf4 (\cf7 tileIndex\cf4 : tileIndex, \cf7 y\cf4 : y);\
            
\f0\b \cf2 let
\f1\b0 \cf4  secondByte: \cf9 UInt8\cf4  = \cf7 tileByteCalculaion\cf4 (\cf7 tileIndex\cf4 : tileIndex, \cf7 y\cf4 : y + \cf6 1\cf4 );\
            
\f0\b \cf2 let
\f1\b0 \cf4  colorValue: [\cf9 UInt8\cf4 ] = \cf7 GetTileLineBytes\cf4 (\cf7 firstByte\cf4 : firstByte, \cf7 secondByte\cf4 : secondByte);\
            
\f0\b \cf2 for
\f1\b0 \cf4  x 
\f0\b \cf2 in
\f1\b0 \cf4  \cf6 0\cf4 ..<\cf6 8\cf4  \{\
                
\f0\b \cf2 let
\f1\b0 \cf4  pixelColor: \cf9 SKColor\cf4  = \cf7 getPixelColor\cf4 (\cf7 value\cf4 : colorValue[x]);\
                
\f0\b \cf2 let
\f1\b0 \cf4  index = (y * \cf6 8\cf4 ) + x + (\cf9 Int\cf4 (tileIndex) * \cf6 64\cf4 );\
                \cf5 pixelNodes\cf4 [index].color = pixelColor;\
            \}\
        \}\
    \}\
  \
    
\f0\b \cf2 func
\f1\b0 \cf4  \cf11 renderTilemap\cf4 () \{\
        
\f0\b \cf2 var
\f1\b0 \cf4  x = -\cf6 80\cf4 ;\
        
\f0\b \cf2 var
\f1\b0 \cf4  y = \cf6 72\cf4 ;\
        
\f0\b \cf2 var
\f1\b0 \cf4  tileIndex:\cf9 UInt16\cf4  = \cf6 0\cf4 ;\
        
\f0\b \cf2 while
\f1\b0 \cf4  y != -\cf6 120\cf4  \{\
            x = -\cf6 80\cf4 ;\
            
\f0\b \cf2 while
\f1\b0 \cf4  x != \cf6 48\cf4  \{\
                \cf7 renderTile\cf4 (\cf7 tileIndex\cf4 : tileIndex);\
                tileIndex += \cf6 1\cf4 ;\
                x += \cf6 8\cf4 ;\
\
\
\
            \}\
            y -= \cf6 8\cf4 ;\
        \}\
    \}\
\
\cf7 EmuRenderTilemap\cf4 (\cf7 PixelArrayInMemory\cf4 : \cf5 PixelColorsArrayInMemory\cf4 );\
\

\f0\b \cf2 var
\f1\b0 \cf4  \cf11 PixelColorsArrayInMemory\cf4  = \cf9 UnsafeMutablePointer\cf4 <\cf9 SKColor\cf4 >.\cf10 allocate\cf4 (\cf10 capacity\cf4 : \cf6 24576\cf4 );\

\f0\b \cf2 func
\f1\b0 \cf4  \cf11 EmuGetPixelColor\cf4 (\cf11 value\cf4 : \cf9 UInt8\cf4 ) -> \cf9 SKColor\cf4  \{\
    
\f0\b \cf2 switch
\f1\b0 \cf4  value \{\
    
\f0\b \cf2 case
\f1\b0 \cf4  \cf6 0\cf4 :\
        
\f0\b \cf2 return
\f1\b0 \cf4  \cf5 LCDStateInstance\cf4 .\cf5 backGroundColors\cf4 [\cf6 0\cf4 ];  \cf8 // Lightest Green\cf4 \
    
\f0\b \cf2 case
\f1\b0 \cf4  \cf6 1\cf4 :\
        
\f0\b \cf2 return
\f1\b0 \cf4   \cf5 LCDStateInstance\cf4 .\cf5 backGroundColors\cf4 [\cf6 1\cf4 ];  \cf8 // Light Green\cf4 \
    
\f0\b \cf2 case
\f1\b0 \cf4  \cf6 2\cf4 :\
        
\f0\b \cf2 return
\f1\b0 \cf4   \cf5 LCDStateInstance\cf4 .\cf5 backGroundColors\cf4 [\cf6 2\cf4 ];  \cf8 // Dark Green\cf4 \
    
\f0\b \cf2 case
\f1\b0 \cf4  \cf6 3\cf4 :\
        
\f0\b \cf2 return
\f1\b0 \cf4   \cf5 LCDStateInstance\cf4 .\cf5 backGroundColors\cf4 [\cf6 3\cf4 ];  \cf8 // Darkest Green\cf4 \
    
\f0\b \cf2 default
\f1\b0 \cf4 :\
        \cf10 print\cf4 (\cf12 "Invalid color index"\cf4 );\
        \cf10 exit\cf4 (-\cf6 5\cf4 );\
    \}\
\}\
\
\cf8 //Used in GameScene class to get the bytes to render all 8 pixels for a tile.\cf4 \

\f0\b \cf2 let
\f1\b0 \cf4  \cf11 binaryNumbers\cf4 : [\cf9 UInt8\cf4 ] = [\cf6 0b10000000\cf4 , \cf6 0b01000000\cf4 , \cf6 0b00100000\cf4 , \cf6 0b00010000\cf4 , \cf6 0b00001000\cf4 , \cf6 0b00000100\cf4 , \cf6 0b00000010\cf4 , \cf6 0b00000001\cf4 ];\

\f0\b \cf2 func
\f1\b0 \cf4  \cf11 EmuGetTileLineBytes\cf4 (\cf11 firstByte\cf4 : \cf9 UInt8\cf4 , \cf11 secondByte\cf4 : \cf9 UInt8\cf4 ) -> [\cf9 UInt8\cf4 ] \{\
    
\f0\b \cf2 var
\f1\b0 \cf4  i = \cf6 0\cf4 ;\
    
\f0\b \cf2 var
\f1\b0 \cf4  number: \cf9 UInt8\cf4  = \cf6 0\cf4 ;\
    
\f0\b \cf2 var
\f1\b0 \cf4  array: [\cf9 UInt8\cf4 ] = \cf9 Array\cf4 <\cf9 UInt8\cf4 >(repeating: \cf6 0\cf4  , count: \cf6 8\cf4 );\
    
\f0\b \cf2 while
\f1\b0 \cf4  i < \cf6 8\cf4  \{\
        number = \cf6 0\cf4 ;\
        
\f0\b \cf2 if
\f1\b0 \cf4  firstByte & \cf5 binaryNumbers\cf4 [i] != \cf6 0\cf4  \{\
            number |= (\cf6 1\cf4  <<  \cf6 1\cf4 );\
        \}\
        
\f0\b \cf2 if
\f1\b0 \cf4  secondByte & \cf5 binaryNumbers\cf4 [i] != \cf6 0\cf4  \{\
            number |= \cf6 1\cf4 ;\
        \}\
        array[i] = number\
        i += \cf6 1\cf4 ;\
    \}\
    
\f0\b \cf2 return
\f1\b0 \cf4  array;\
\}\
\
\cf8 //Each tile is composed of 16 bytes. Each line is 2 bytes vram starts at address 0x8000\cf4 \

\f0\b \cf2 func
\f1\b0 \cf4  \cf11 EmuTileByteCalculaion\cf4 (\cf11 tileIndex\cf4 : \cf9 UInt16\cf4 , \cf11 y\cf4 : \cf9 Int\cf4 ) -> \cf9 UInt8\cf4  \{\
    
\f0\b \cf2 let
\f1\b0 \cf4  tileOffset:\cf9 UInt16\cf4  = tileIndex * \cf6 16\cf4 ;\
    
\f0\b \cf2 let
\f1\b0 \cf4  rowOffset:\cf9 UInt16\cf4   = \cf9 UInt16\cf4 (y * \cf6 2\cf4 );\
    
\f0\b \cf2 let
\f1\b0 \cf4  address:\cf9 UInt16\cf4  = tileOffset + rowOffset;\
    
\f0\b \cf2 return
\f1\b0 \cf4  \cf5 PPUStateInstance\cf4 .\cf5 vram\cf4 [\cf9 Int\cf4 (address)];\
\}\
\

\f0\b \cf2 func
\f1\b0 \cf4  \cf11 EmuRenderTile\cf4 ( \cf11 tileIndex\cf4 : \cf9 UInt16\cf4 ) \{\
   \cf8 // let tileSize = CGSize(width: 8, height: 8);\cf4 \
    \cf8 // Loop through each pixel in the tile and set its color based on the UInt8 value\cf4 \
    
\f0\b \cf2 for
\f1\b0 \cf4  y 
\f0\b \cf2 in
\f1\b0 \cf4  \cf6 0\cf4 ..<\cf6 8\cf4  \{\
        
\f0\b \cf2 let
\f1\b0 \cf4  firstByte: \cf9 UInt8\cf4  = \cf7 EmuTileByteCalculaion\cf4 (\cf7 tileIndex\cf4 : tileIndex, \cf7 y\cf4 : y);\
        
\f0\b \cf2 let
\f1\b0 \cf4  secondByte: \cf9 UInt8\cf4  = \cf7 EmuTileByteCalculaion\cf4 (\cf7 tileIndex\cf4 : tileIndex, \cf7 y\cf4 : y + \cf6 1\cf4 );\
        
\f0\b \cf2 let
\f1\b0 \cf4  colorValue: [\cf9 UInt8\cf4 ] = \cf7 EmuGetTileLineBytes\cf4 (\cf7 firstByte\cf4 : firstByte, \cf7 secondByte\cf4 : secondByte);\
        
\f0\b \cf2 for
\f1\b0 \cf4  x 
\f0\b \cf2 in
\f1\b0 \cf4  \cf6 0\cf4 ..<\cf6 8\cf4  \{\
            
\f0\b \cf2 let
\f1\b0 \cf4  pixelColor: \cf9 SKColor\cf4  = \cf7 EmuGetPixelColor\cf4 (\cf7 value\cf4 : colorValue[x]);\
            
\f0\b \cf2 let
\f1\b0 \cf4  index = (y * \cf6 8\cf4 ) + x + (\cf9 Int\cf4 (tileIndex) * \cf6 64\cf4 );\
            \cf5 PixelColorsArrayInMemory\cf4 [index] = pixelColor;\
        \}\
    \}\
\}\
\

\f0\b \cf2 func
\f1\b0 \cf4  \cf11 EmuRenderTilemap\cf4 (\cf11 PixelArrayInMemory\cf4 : \cf9 UnsafeMutablePointer\cf4 <\cf9 SKColor\cf4 >) \{\
    
\f0\b \cf2 var
\f1\b0 \cf4  tileIndex:\cf9 UInt16\cf4  = \cf6 0\cf4 ;\
    
\f0\b \cf2 while
\f1\b0 \cf4  tileIndex * \cf6 64\cf4  < \cf6 24576\cf4  \{\
        \cf7 EmuRenderTile\cf4 (\cf7 tileIndex\cf4 : tileIndex);\
        tileIndex += \cf6 1\cf4 ;\
    \}\
\}\
\pard\tx642\pardeftab642\pardirnatural\partightenfactor0

\fs26 \cf4 \cb17   
\f0\b \cf2 var
\f1\b0 \cf4  \cf11 x\cf4  = -\cf6 80\cf4 ;\
        
\f0\b \cf2 var
\f1\b0 \cf4  \cf11 y\cf4  = \cf6 72\cf4 ;
\fs24 \cb3 \

\fs26 \cb17  
\f0\b \cf2 while
\f1\b0 \cf4  y != -\cf6 120\cf4  \{\
            x = -\cf6 80\cf4 ;\
            
\f0\b \cf2 while
\f1\b0 \cf4  x != \cf6 48\cf4  \{
\fs24 \cb3 \
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0
\cf4 \
\pard\tx642\pardeftab642\pardirnatural\partightenfactor0

\fs32 \cf4 \
\
\
\pard\tx642\pardeftab642\pardirnatural\partightenfactor0

\fs26 \cf4  
\f0\b \cf2 func
\f1\b0 \cf4  \cf11 touchDown\cf4 (\cf11 atPoint\cf4  pos : \cf9 CGPoint\cf4 ) \{\
        
\f0\b \cf2 if
\f1\b0 \cf4  
\f0\b \cf2 let
\f1\b0 \cf4  n = 
\f0\b \cf2 self
\f1\b0 \cf4 .\cf5 spinnyNode\cf4 ?.\cf10 copy\cf4 () 
\f0\b \cf2 as
\f1\b0 \cf4 ! \cf16 \cb3 SKShapeNode\cf4 \cb3 ? \{\
            n.\cf13 position\cf4  = pos\
            n.\cf13 strokeColor\cf4  = \cf9 SKColor\cf4 .\cf13 green\cf4 \
            
\f0\b \cf2 self
\f1\b0 \cf4 .\cf10 addChild\cf4 (n)\
        \}\
    \}\
    \
    
\f0\b \cf2 func
\f1\b0 \cf4  \cf11 touchMoved\cf4 (\cf11 toPoint\cf4  pos : \cf9 CGPoint\cf4 ) \{\
        
\f0\b \cf2 if
\f1\b0 \cf4  
\f0\b \cf2 let
\f1\b0 \cf4  n = 
\f0\b \cf2 self
\f1\b0 \cf4 .\cf5 spinnyNode\cf4 ?.\cf10 copy\cf4 () 
\f0\b \cf2 as
\f1\b0 \cf4 ! \cf16 \cb3 SKShapeNode\cf4 \cb3 ? \{\
            n.\cf13 position\cf4  = pos\
            n.\cf13 strokeColor\cf4  = \cf9 SKColor\cf4 .\cf13 blue\cf4 \
            
\f0\b \cf2 self
\f1\b0 \cf4 .\cf10 addChild\cf4 (n)\
        \}\
    \}\
    \
    
\f0\b \cf2 func
\f1\b0 \cf4  \cf11 touchUp\cf4 (\cf11 atPoint\cf4  pos : \cf9 CGPoint\cf4 ) \{\
        
\f0\b \cf2 if
\f1\b0 \cf4  
\f0\b \cf2 let
\f1\b0 \cf4  n = 
\f0\b \cf2 self
\f1\b0 \cf4 .\cf5 spinnyNode\cf4 ?.\cf10 copy\cf4 () 
\f0\b \cf2 as
\f1\b0 \cf4 ! \cf16 \cb3 SKShapeNode\cf4 \cb3 ? \{\
            n.\cf13 position\cf4  = pos\
            n.\cf13 strokeColor\cf4  = \cf9 SKColor\cf4 .\cf13 red\cf4 \
            
\f0\b \cf2 self
\f1\b0 \cf4 .\cf10 addChild\cf4 (n)\
        \}\
    \}\
    \
    
\f0\b \cf2 override
\f1\b0 \cf4  
\f0\b \cf2 func
\f1\b0 \cf4  \cf11 mouseDown\cf4 (\cf11 with\cf4  event: \cf16 \cb3 NSEvent\cf4 \cb3 ) \{\
        
\f0\b \cf2 self
\f1\b0 \cf4 .\cf7 touchDown\cf4 (\cf7 atPoint\cf4 : event.\cf10 location\cf4 (\cf10 in\cf4 : 
\f0\b \cf2 self
\f1\b0 \cf4 ))\
    \}\
    \
    
\f0\b \cf2 override
\f1\b0 \cf4  
\f0\b \cf2 func
\f1\b0 \cf4  \cf11 mouseDragged\cf4 (\cf11 with\cf4  event: \cf16 \cb3 NSEvent\cf4 \cb3 ) \{\
        
\f0\b \cf2 self
\f1\b0 \cf4 .\cf7 touchMoved\cf4 (\cf7 toPoint\cf4 : event.\cf10 location\cf4 (\cf10 in\cf4 : 
\f0\b \cf2 self
\f1\b0 \cf4 ))\
    \}\
    \
    
\f0\b \cf2 override
\f1\b0 \cf4  
\f0\b \cf2 func
\f1\b0 \cf4  \cf11 mouseUp\cf4 (\cf11 with\cf4  event: \cf16 \cb3 NSEvent\cf4 \cb3 ) \{\
        
\f0\b \cf2 self
\f1\b0 \cf4 .\cf7 touchUp\cf4 (\cf7 atPoint\cf4 : event.\cf10 location\cf4 (\cf10 in\cf4 : 
\f0\b \cf2 self
\f1\b0 \cf4 ))\
    \}
\fs32 \
}